---
title: "Explore the available data sources"
output: 
  - rmarkdown::html_notebook
  - rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Raw-data-exploration}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  cache = TRUE
)
```

```{r setup, echo=TRUE, }
library("data.table")
library("dplyr")
library("sf")
library("here")
library("knitr")
source("R/helpers_data-import.R" %>% here())
load_raw_data <- get_raw_data_loaders()
```


# What information do we need?

The objective of the project is to create a gravity model of retail sales.
This models the commercial flows from the point were clients live to the stores of customers.

+ We need information on the origins of the customers which is on IRIS level.
+ We need information on the destinations which are the shops.
+ We need informations on pairs of origins and destinations (distance and amounts of flows).

To collect this information we have 4 internal sources of geomarketing data.  
Additional information has to be found on open sources.


## Investigate the geomarketing data

We have four data sources on geomarketing information.

### A glimpse on the geomarketing sources

```{r loadGeoData}
client_shops <- load_raw_data$client_shops()
head(client_shops)

client_customers <- load_raw_data$client_customers()
head(client_customers)

market_potential <- load_raw_data$market_potential()
head(market_potential)

sirene_competitors <- load_raw_data$competitors()
head(sirene_competitors)

```


## Investiage the INSEE data

We consider additional data from the INSEE.
From the data we want to extract the population and the income of the IRIS from which the customers are coming.

### A glimpse on the geomarketing sources


```{r loadInseeData}
iris_pop <- load_raw_data$iris_pop()
head(iris_pop)

iris_income <- load_raw_data$iris_income()
head(iris_income)

fr_mun_income <- load_raw_data$mun_income()
fr_mun_income
```

### Check for missing income data

Check the availability of income data.
More than half of the IRIS where our clients come from do not have information on income.
We have to think about an imputation mechanism if we want to use this variable.
Available imputations are data on municipalities level or data on grid level.

```{r checkIrisIncome}
iris_with_income_data <- iris_income %>% 
  filter(!is.na(iris_income$DISP_MED17)) %>% 
  pull(IRIS) %>% 
  unique()

# the customers of our client are in 21720 IRIS
client_iris <- client_customers$IRIS %>% unique()
length(client_iris)

has_income <- client_iris %in% iris_with_income_data
# for 10393 of these IRIS we have information on the median income
sum(has_income)
# for 11327 of these IRIS we do not have information on the median income
sum(!has_income)
```

Test if we can impute this data from the municipalities.

```{r checkMunIncome}
clients_mun <- client_customers %>% 
  as.data.frame() %>% 
  select(IRIS) %>% unique() %>% setDT()

# correspondence between customers MUN and IRIS
iris_pop %>% setDT()
clients_mun[iris_pop,ID_MUN := COM, on = "IRIS",allow.cartesian = FALSE]

iris_income %>% setDT()
fr_mun_income %>% setDT()
clients_region_incomes <- clients_mun %>% copy()
clients_region_incomes[iris_income,MEDIAN_INCOME_IRIS := DISP_MED17,
                       on = "IRIS"]
clients_region_incomes[fr_mun_income,MEDIAN_INCOME_MUN := Q217,
                       on = c(ID_MUN = "CODGEO")]
clients_region_incomes[,MEDIAN_INCOME_1 := if_else(is.na(MEDIAN_INCOME_IRIS),
                                                   true = MEDIAN_INCOME_MUN,
                                                   false =MEDIAN_INCOME_IRIS)]
```
First check how well the identification between IRIS and municipalities works.

```{r checkIdMunIris}
# 21614 of the customers IRIS are identified with a municipality
nrow(clients_mun %>% filter(complete.cases(.)))
# we would loose 0.4880295 % of the customers location
1 - nrow(clients_mun %>% filter(complete.cases(.))) / nrow(clients_mun)

no_id_iris <- clients_mun %>% filter(!complete.cases(.)) %>% pull(IRIS)
losses <- client_customers %>% 
  as.data.frame() %>% 
  filter(IRIS %in% no_id_iris) %>% 
  summarise(lost_entiries = n(), lost_sales = sum(sales))
# this corresponds to 885 observations and 563536	of sales
losses
totals <- client_customers %>% 
  as.data.frame() %>% 
  summarise(lost_entiries = n(), lost_sales = sum(sales))
# as percentages 0.598608 % of observations, 0.5226266% of sales
losses / totals
```

Then check of complete the information on income is.
For now we can live with this result and decide drop some information from the data.

```{r checkIdIncomeIris}
# 21588 of the clients IRIS are identified with incomes based on MUN or IRIS
clients_incs <- clients_region_incomes %>% 
  select("IRIS", "MEDIAN_INCOME_1")
nrow(clients_incs %>% filter(complete.cases(.)))
# we would loose 0.6077348 % of the customers location
1 - nrow(clients_incs %>% filter(complete.cases(.))) / nrow(clients_incs)

no_id_iris <- clients_incs %>% filter(!complete.cases(.)) %>% pull(IRIS)
losses <- client_customers %>% 
  as.data.frame() %>% 
  filter(IRIS %in% no_id_iris) %>% 
  summarise(lost_entiries = n(), lost_sales = sum(sales))
# this corresponds to 825 observations and 551830	of sales
losses
totals <- client_customers %>% 
  as.data.frame() %>% 
  summarise(lost_entiries = n(), lost_sales = sum(sales))
# as percentages 0.5580244 % of observations, 0.5117703% of sales
losses / totals
```


## Investigate identification with the geometries


We can secure identification of all data points by looking at some of the previous definition of the IRIS geometries and by 

```{r loadIgnData}
iris_poly19 <- load_raw_data$iris_poly19()
iris_poly16 <- load_raw_data$iris_poly16()
iris_poly15 <- load_raw_data$iris_poly15()
iris_poly14 <- load_raw_data$iris_poly14()

geomarketing_iris <- market_potential$IRIS
length(unique(geomarketing_iris))
length(unique(iris_poly19$CODE_IRIS))
length(unique(iris_poly16$CODE_IRIS))
length(unique(iris_poly15$CODE_IRIS))
length(unique(iris_poly14$DCOMIRIS))

# based on 2019 IRIS we can not identify 1809 regions
sum(!geomarketing_iris %in% iris_poly19$CODE_IRIS)

# based on 2016 IRIS we can not identify 834 regions
sum(!geomarketing_iris %in% iris_poly16$CODE_IRIS)

# based on 2015 IRIS we can not identify 39 regions
sum(!geomarketing_iris %in% iris_poly15$CODE_IRIS)
loss <- sum(market_potential$mp[!geomarketing_iris %in% iris_poly15$CODE_IRIS])
loss/ sum(market_potential$mp)


# based on 2014 IRIS we can not identify 9 regions
sum(!geomarketing_iris %in% iris_poly14$DCOMIRIS)

# based on 2014 + 2015 IRIS we can not identify 4 regions
sum(!geomarketing_iris %in% c(iris_poly14$DCOMIRIS,iris_poly15$CODE_IRIS))

orphan_iris <- market_potential$IRIS[
  !geomarketing_iris %in% c(iris_poly14$DCOMIRIS,iris_poly15$CODE_IRIS)]

# The changes are due to commune redefinitions map the IRIS to communes
# 1) 76108XXXX -> 76095
# https://www.insee.fr/fr/metadonnees/cog/commune/COM76108-bois-guillaume
new_commune1 <- iris_poly19$CODE_IRIS[grep("76095",iris_poly19$CODE_IRIS)]
new_commune1 %in% geomarketing_iris

# 2)  52379XXX -> 52187 (fusion)
# https://www.insee.fr/fr/metadonnees/cog/commune/COM52379-pautaines-augeville
new_commune2 <- iris_poly19$CODE_IRIS[grep("52187",iris_poly19$CODE_IRIS)]
new_commune2 %in% geomarketing_iris
geomarketing_iris[grep("(52187|52379)",geomarketing_iris)]
iris_poly19$CODE_IRIS[grep("(52187|52379)",iris_poly19$CODE_IRIS)]
```





